/**
 * phant-stream-csv
 * https://github.com/sparkfun/phant-stream-csv
 *
 * Copyright (c) 2014 SparkFun Electronics
 * Licensed under the GPL v3 license.
 */

'use strict';

/**** Module dependencies ****/
var stream = require('stream'),
    helpers = require('./helpers'),
    path = require('path'),
    util = require('util'),
    fs = require('fs');

/**** Make Readable a readable stream ****/
util.inherits(Readable, stream.Readable);

/**** Readable prototype ****/
var app = Readable.prototype;

/**** Expose Readable ****/
exports = module.exports = Readable;

/**** Initialize a new Readable ****/
function Readable(id, options) {

  if (! (this instanceof Readable)) {
    return new Readable(id, options);
  }

  options = util._extend({
    highWaterMark: 64 * 1024 // 64k
  }, options || {});

  stream.Readable.call(this, options);

  // id generated by metadata module
  this.id = id;

  // apply the options
  util._extend(this, options);

  // point the file helpers at passed root folder
  this.helpers = helpers({root: this.root});

  // generate the file path based on ID
  this.getFilePath(this.page);

  // once we have a path, open the file
  // for reading and writing
  this.once('path', function() {
    this.open();
  });

  this.once('finish', this.close);

}

app.file = null;
app.page = 1;
app.all = false;
app.root = path.join('tmp');
app.flags = 'r'; // read
app.mode = 438; // 0666

app.getFilePath = function(page) {

  var self = this;

  page = page || 1;

  this.helpers.filePath(this.id, page, function(err, file) {

    self.file = file;

    self.emit('path', self.file);

  });

};

app.open = function() {

  var self = this;

  if(! this.file) {
    return this.once('path', function() {
      self.open();
    });
  }

  fs.open(this.file, this.flags, this.mode, function(err, fd) {

    if(err) {
      self.emit('error', err);
      return;
    }

    self.fd = fd;

    fs.fstat(fd, function(err, st) {

      if(err) {
        return this.emit('error', err);
      }

      self.pos = st.size;
      self.emit('open', fd);

    });

  });

};

app.nextPage = function() {

  var self = this,
      next = this.page + 1;

  this.close();

  this.helpers.filePath(this.id, next, function(err, file) {

    if(err) {
      return self.push(null);
    }

    fs.exists(file, function(exists) {

      if(exists) {
        self.page = next;
        self.file = file;
        return self.open();
      }

      self.push(null);

    });

  });

};

app._read = function() {

  var self = this,
      buffer = new Buffer(5 * 1024);

  if(typeof this.fd !== 'number') {
    return this.once('open', function() {
      this._read();
    });
  }

  // output headers if they haven't been read
  if(! this.headersRead) {
    return this.readHeaders();
  }

  // don't read past the beginning of the file
  if((this.pos - buffer.length) < 0) {
    buffer = new Buffer(Math.abs(this.pos));
  }

  // if we are at the beginning of this file,
  // check if we should send more
  if(this.pos === 0) {

    // no more
    if(! this.all) {
      return this.push(null);
    }

    // try the next file
    this.nextPage();

    return this.once('open', function() {
      this._read();
    });

  }

  fs.read(this.fd, buffer, 0, buffer.length, this.pos - buffer.length, onread);

  function onread(err, bytesRead, buf) {

    var line = [];

    if(err) {
      return self.emit('error', err);
    }

    // check if there is a partial line from the last read
    if(self.previousChunk instanceof Array) {
      line = line.concat(self.previousChunk);
      self.previousChunk = null;
    }

    for(var i = buf.length - 1; i >= 0; i--) {

      // separate at new lines
      if(buf[i] === 0x0a) {

        // make sure we have something to push
        if(line.length > 1) {

          // add delimiter char to the end
          line.push(0x0a);

          // move cursor to the current position
          self.pos--;

          // push line
          self.push(new Buffer(line));

          // empty vars
          line = null;
          buffer = null;

          return;

        }

      } else {

        // prepend char to the current line
        line.unshift(buf[i]);

      }

      // move cursor to the current position
      self.pos--;

    }

    // we are done reading this file
    // so push the line
    if(self.pos === 0) {

      if(line.length > 0) {

        // add new line
        line.push(0x0a);

        // push line
        self.push(new Buffer(line));

        // empty vars
        line = null;
        buffer = null;

        return;

      }

    }

    // if not, save it for the next read
    if(line instanceof Array && line.length > 0) {
      self.previousChunk = line;
      self._read();
    }

  }

};

app.readHeaders = function() {

  var self = this;

  if(this.headersRead) {
    return;
  }

  this.helpers.headerPath(this.id, function(err, file) {

    if(err) {
      return self.emit('error', err);
    }

    fs.readFile(file, function(err, data) {

      if(err) {
        return self.emit('error', err);
      }

      self.headersRead = true;
      self.push(data, 'utf8');

    });

  });

};

app.close = function() {

  var self = this;

  fs.close(this.fd, function(err) {

    if(err) {
      self.emit('error', err);
    }

  });

};

